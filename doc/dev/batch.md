<img src='../assets/aktive-logo-128.png' style='float:right;'>

||||
|---|---|---|
|[Project ↗](../../README.md)|[Documentation ↗](../index.md)|[Developer Index ↗](index.md)|


# Batch Processor

The foundation for the horizontal threading.

## Implementation files

  - [runtime/batch.h](/file?ci=trunk&name=runtime/batch.h)
  - [runtime/batch.c](/file?ci=trunk&name=runtime/batch.c)

## Users

Batch processors are currently used to

 - [Compute Connected Components](cc.md)
 - [Export images to files](../ref/sink_writer.md)
 - [Reduce images to statistics](../ref/sink_statistics.md)

## Overview

The batch processor is the core of AKTIVE's horizontal threading.

The [main entry point](/file?ci=trunk&name=runtime/batch.h&ln=96) is invoked
with a configuration flag, batch specific state information, and three function
vectors, the

  - `maker` to generate `tasks`,
  - `worker` to receive `tasks` and generate `results`, and
  - `completer` to receive `results` for final processing.

The state is not touched by the processor, just passed through to the
functions. The flag determines the exact [mode](#emodes) of operation.

Note that to the batch processor the aforementioned `tasks` and `results` are
all `void*`, and it does not care about their internal structure.  `NULL` is the
only value it cares about, treating it as a stop signal.  The functions
themselves have to agree on their structures however, of course.

The functions all run in their own threads, communicating by queues.  Note that
while `maker` and `completer` exist only once the `worker` is instantiated
[CPU count](../ref/miscellaneous.md#processors) times.

The `completer` thread is actually virtual. The main thread performs this action
after it spawned and initialized maker and workers, until all results were
received and the processor is done.

## Functions

### Maker

On each call a `maker` function has to return a new `task` for the workers to
perform, or `NULL`.

The latter indicates to the batch processor that the pool of tasks is exhausted.

As the maker is executed in its own thread the maker can block and wait for some
condition before it returns. The calculation of [Connected Components](cc.md)
uses this to delay returning a `NULL` until it is given the go-ahead by the
associated completer.

### Worker

On each call the `worker` is given either a `task` to perform, or `NULL`.

The latter indicates that there are no more tasks to follow, and that the worker
has to properly shutdown itself now. This is especially includes cleanup of any
per-worker state it used. Note that the batch ignores the result of this
invokation.

For an invokation with an actual task the worker has to perform the specified
task and then return a result for it.

On the first call (`wstate == NULL`) it may initialize this per-worker state,
should such a thing be needed by the overall operation. When doing so the state
has to be cleaned up again on the last call, see above.

An example of such a state would be a scratch buffer for transient data.
Allocating and releasing such per call would induce lots of memory churn
which is better avoided.

### Completer

On each call the `completer` is given either a `result`, or `NULL`.

The latter indicates that there are no more results to follow, and that the
completer has to properly shutdown itself now.

For an invokation with an actual result the completer has to perform whatever
is necessary for the overall operation.

As examples, for the file sinks this is writing the data to the file, whereas
for the reductions this is the incremental consolidation of the partial results
into the final complete result, the statistic to return.

__Different__ from `maker` and `worker` the `completer` has access to the batch
processor itself. This enables it to inject additional tasks into the system,
outside of the tasks generated by the maker.

This is used, for example, in the calculation of [Connected Components](cc.md).

## <a name='emodes'></a> Execution modi

Batch processors can be run in one of two execution modi, `sequential`, and
`non-sequential`.

The first mode should only be used if the order in which results arrive at the
completer matters to the operation. Most often it does not. So far `sequential`
mode was only required when writing an image to a file where the file format
prevents random access to arbitrary pixel locations. In other words, the text
forms of the Netpbm file formats.

Everything else uses `non-sequential` mode, where results may arrive at the
completer in arbitrary order.

In this mode `workers` and `completer` communicate through a regular fifo queue.

In `sequential` mode however this is replaced by a ping/pong signaling scheme,
where the `completer` signals the id of the task/result it is willing to accept
whenver it is ready to do so (ping), and only the `worker` having that result
will place it into the return slot and signal its availability back (pong).

The workers having an unwanted result on the other hand go to sleep and recheck
whenever the completer's ping wakes them all up to see if their result is now
requested.
