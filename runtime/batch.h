/* -*- c -*-
 * - - -- --- ----- -------- -------------
 *
 * -- Runtime API -- Batch processing
 *
 * Batch processors handle a task by spawning a number of threads operating
 * concurrently on independent parts of the whole.
 *
 * A batch processor is specified through 3 functions
 *
 *  - A task generator. It produces the tasks to preform and places them into a queue.
 *  - A worker. Workers dequeue tasks from their queue, generate a result, and queue them.
 *  - A task completer. It dequeues results from their queue and integrates them into the
 *    final result.
 *
 * Each batch processor runs a single generator, several workers and a single
 * completer. All execute concurrently. The run ends when the completer has
 * seen and handled the last task made by the generator.
 *
 * Note: In __sequential__ mode the batch processor ensures that the completer
 *       sees worker results in the same order as the associated tasks were
 *       created in. It internally delays results created early, i.e. out of
 *       order, as needed.
 *
 *       When sequential is not asked for the completer sees the results in
 *       arbitrary order, as the workers generate them.
 *
 * A batch processor returns when all its tasks have been done and completed.
 */
#ifndef AKTIVE_BATCH_H
#define AKTIVE_BATCH_H

/*
 * - - -- --- ----- -------- -------------
 * Handle to batch processor instance.
 */

typedef struct aktive_batch* aktive_batch;

/*
 * - - -- --- ----- -------- -------------
 *
 * - create   :: return one task per call, until all tasks are created
 *            :: return NULL when there are no tasks anymore.
 * - work     :: Take and process task, return a result.
 *            :: A NULL task indicates a last call for cleanup, etc.
 * - complete :: Take and process result. A NULL result indicates a last
 *            :: call for cleanup, etc.
 *
 * All have access to the user-specified state. Create and complete can work
 * concurrently without locking if they modify different parts of that
 * state. If they access the same fields they have to lock. Work has only
 * read-only access.
 *
 * The `wstate*` workers have access to is a per-worker void* field they can
 * use as they see fit. When they use they have to initialize it on first call
 * and teardown on last.
 *
 * Maker function API.
 *
 *  On each call return a single task structure, or NULL.
 *  NULL indicates that all tasks werde made. EOF is reached.
 *
 * Worker function API
 *
 *  A call with a NULL task indicates that EOF was reached. There are no more
 *  tasks to handle, perform a proper shutdown of yourself. Especially of the
 *  `wstate` if it was used. Any result from such a call is ignored.
 *
 *  A call with a non-NULL task is the next task to operate on. Return the
 *  result of that operation.
 *
 *  A call with `wstate == NULL` is the first call, initialize it, if needed
 *  by the overall operation.
 *
 * Completer function API
 *
 *  A call with a NULL result indicates EOF. Perform any needed finalizations.
 *
 *  A call with a non-NULL result indicates partial data. Do as needed per the
 *  overall operation in progress.
 *
 *  The completer is the only vector with access to the batch processor.
 *  This enables the completer to inject additional tasks into the system,
 *  outside of the tasks generated by the maker.
 */

typedef void* (*aktive_batch_make)     (                     void* state);
typedef void* (*aktive_batch_work)     (               const void* state, void* task, void** wstate);
typedef void  (*aktive_batch_complete) (aktive_batch b,      void* state, void* result);

/*
 * - - -- --- ----- -------- -------------
 */

extern void aktive_batch_run ( const  char*          name
	   		     , aktive_batch_make     maker
	   		     , aktive_batch_work     worker
	   		     , aktive_batch_complete completer
			     , aktive_uint           sequential
	   		     , void*                 state);

/* Inject additional task into the batch. Usable only by completion vectors.
 * Usable only with non-sequential batch processes. The inject tasks is
 * automatically high priority, i.e. placed before all other waiting tasks.
 */
extern void aktive_batch_inject (aktive_batch b, void* task);

/*
 * - - -- --- ----- -------- -------------
 */

/*
 * = = == === ===== ======== ============= =====================
 * Local Variables:
 * mode: c
 * c-basic-offset: 4
 * fill-column: 78
 * End:
 */
#endif /* AKTIVE_BATCH_H */
